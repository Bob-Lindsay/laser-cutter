#!/usr/bin/env ruby
require 'laser-cutter'
require 'optparse'
require 'colored'
require 'json'
require 'hashie/mash'

module Laser
  module Cutter
    class OptParse
      def self.puts_error(e)
        STDERR.puts "Whoops, #{e}".red
        STDERR.puts "Try --help or --examples for more info...".yellow
      end

      def self.parse(args)
        banner_text = <<-EOF
#{('Laser-Cutter v'+ Laser::Cutter::VERSION).bold}

Usage: laser-cutter [options] -o filename.pdf
   eg: laser-cutter -i -s 1x1.5x2/0.125/0.125 -O -o box.pdf
        EOF

        examples = <<-EOF

Examples:
  1. Create a box defined in inches, and open PDF in preview right after:

       laser-cutter -i -s 3x2x2/0.125/0.5 -O -o box.pdf

  2. Create a box defined in millimeters, print verbose info and set
     page size to A3, and layout to landscape, and stroke width to 1/2mm:

       laser-cutter -w70 -h20 -d50 -t4.3 -n5 -PA3 -L landscape -S0.5 -v -O -o box.pdf

  3. List all possible page sizes in metric or imperial systems:

       laser-cutter --list-all-page-sizes
       laser-cutter --list-all-page-sizes --inches
        EOF
        options = Hashie::Mash.new
        options.verbose = false
        options.units = 'mm'

        opt_parser = OptionParser.new do |opts|
          opts.banner = banner_text.blue
          opts.separator "Specific Options:"
          opts.on("-w", "--width WIDTH", "Internal width of the box") { |value| options.width = value }
          opts.on("-h", "--height HEIGHT", "Internal height of the box") { |value| options.height = value }
          opts.on("-d", "--depth DEPTH", "Internal depth of the box") { |value| options.depth= value }
          opts.on("-t", "--thickness THICKNESS", "Thickness of the box material") { |value| options.thickness = value }
          opts.on("-n", "--notch NOTCH", "Preferred notch length (used only as a guide)") { |value| options.notch = value }
          opts.separator ""
          opts.on("-m", "--margin MARGIN", "Margins from the edge of the document") { |value| options.margin = value }
          opts.on("-p", "--padding PADDING", "Space between the boxes on the page") { |value| options.padding = value }
          opts.on("-t", "--stroke WIDTH", "Numeric stroke width of the line") { |value| options.stroke = value }
          opts.on("-z", "--page_size LETTER", "Page size, see --list-all-page-sizes for more info.") { |value| options.page_size = value }
          opts.on("-y", "--page_layout portrait", "Page layout, other option is 'landscape' ") { |value| options.page_layout = value }
          opts.separator ""
          opts.on("-O", "--open", "Open generated file with system viewer before exiting") { |v| options.open = v }
          opts.on("-w", "--write FILE", "Save current configuration to a file, use '-' for STDOUT") { |v| options.write_file = v }
          opts.on("-r", "--read FILE", "Read configuration from a file, use '-' for STDIN") { |v| options.read_file = v }
          opts.on("-u", "--units UNITS", "Either 'mm' (default) or 'in'") { |value| options.units = value }
          opts.separator ""
          opts.on("-l", "--list-all-page-sizes", "Print all available page sizes with dimensions and exit") { |v| options.list_all_page_sizes = true }
          opts.on("-M", "--no-metadata", "Do not print box metadata on the PDF") { |value| options.metadata = value }
          opts.on("-v", "--[no-]verbose", "Run verbosely") { |v| options.verbose = v }
          opts.separator ""
          opts.on("--examples", "Show detailed usage examples") { puts opts; puts examples.yellow; exit }
          opts.on("--help", "Show this message") { puts opts; exit }
          opts.on("--version", "Show version") { puts Laser::Cutter::VERSION; exit }
          opts.separator ""
          opts.separator "Common Options:"
          opts.on_tail("-o", "--file FILE", "Required output filename of the PDF") { |value| options.file = value }
          opts.on_tail("-s", "--size WxHxD/T/N",
                       "Combined internal dimensions: W = width, H = height,\n#{" " * 37}D = depth, T = thickness, N = notch length\n\n") do |size|
            options.size = size
          end
          opts.on_tail("-i", "--inches", "Switch measurements to inches instead of millimeters") { |value| options.units = 'in' }
        end

        opt_parser.parse!(args)

        if options.read_file
          read_options_from_file(options)
        end

        config = Laser::Cutter::Configuration.new(options.to_hash)
        if config.list_all_page_sizes
          puts config.all_page_sizes
          exit 0
        end

        if options.verbose
          puts "Starting with the following configuration:"
          puts JSON.pretty_generate(config.to_hash).green
        end

        config.validate!

        if config.write_file
          write_options_to_file(config)
        end

        config
      rescue OptionParser::InvalidOption, OptionParser::MissingArgument, Laser::Cutter::MissingOption => e
        puts opt_parser.banner.blue
        puts_error(e)
        exit 1
      end

      def self.read_options_from_file(options)
        string = if options.read_file.eql?('-')
                   $stdin.read
                 elsif File.exist?(options.read_file)
                   File.read(options.read_file)
                 end
        if string
          options.replace(JSON.load(string))
        end
      rescue Exception => e
        STDERR.puts "Error reading options from file #{options.read_file}, #{e.message}".red
        if options.verbose
          STDERR.puts e.backtrace.join("\n").red
        end
        exit 1
      end

      def self.write_options_to_file(options)
        output = if options.write_file.eql?('-')
                   $stdout
                 elsif options.write_file
                   File.open(options.write_file, 'w')
                 else
                   nil
                 end
        output.puts(JSON.pretty_generate(options))
        output.close if output != $stdout
      rescue Exception => e
        STDERR.puts "Error writing options to file #{options.write_file}, #{e.message}".red
        if options.verbose
          STDERR.puts e.backtrace.join("\n").red
        end
        exit 1
      end
    end
  end
end # class OptParse

config = Laser::Cutter::OptParse.parse(ARGV)

begin
  Laser::Cutter::Renderer::BoxRenderer.new(config).render
  if config.open
    `open #{config.file}`
  end
rescue Exception => e
  puts_error(e)
  if options.verbose
    STDERR.puts "Exception: #{e.inspect}".red
    STDERR.puts e.backtrace.join("\n").red
  end
end


